# 异步转录功能说明

## ✨ 新特性

现在转录采用**异步队列**机制，大幅提升用户体验！

### 🎯 改进前后对比

#### 改进前（同步转录）
```
用户操作：按F2开始 → 按F2停止 → [卡住2-3秒] → 文字输入 → 才能再次按F2
                                 ⬆️ 等待转录完成，无法操作
```

#### 改进后（异步转录）
```
用户操作：按F2开始 → 按F2停止 → [立即] 按F2开始 → 按F2停止 → ...
                                 ⬆️ 无感知，后台处理
                                 
后台队列：            [任务1转录中] → [任务2转录中] → [完成]
```

## 🚀 核心改进

### 1. **立即响应**
- 按F2停止录音后**立即返回**，不等待转录完成
- 可以马上开始下一次录音

### 2. **任务队列**
- 支持快速连续录音，所有任务自动排队处理
- 队列容量：10个任务（可配置）
- 队列满时会记录错误，但不会阻塞用户

### 3. **后台转录**
- 转录在独立线程中进行，不影响主线程
- 转录完成后自动输出文字

### 4. **状态监控**
```python
stats = worker.transcription_stats
# {
#     "submitted": 5,      # 已提交的任务数
#     "completed": 3,      # 已完成的任务数
#     "pending": 2,        # 队列中等待的任务数
#     "is_recording": False,
#     "is_transcribing": True
# }
```

## 📊 使用场景示例

### 场景1：快速连续录音
```
00:00 - 用户按F2，开始录音
00:03 - 用户按F2，停止录音（提交任务1到队列）
00:03 - 立即按F2，开始第二次录音
00:06 - 按F2，停止录音（提交任务2到队列）
00:04 - 任务1转录完成，自动输入文字
00:07 - 任务2转录完成，自动输入文字
```

### 场景2：转录期间可继续录音
```
用户：录制语音1 → 停止（后台开始转录）→ 录制语音2 → 停止（排队）
系统：[转录语音1...] → 输入文字1 → [转录语音2...] → 输入文字2
```

## 🔧 技术实现

### 架构
```
┌─────────────────┐
│   主线程        │  
│  (UI/热键响应)  │  ← F2按键，立即响应
└────────┬────────┘
         │
    ┌────▼────┐
    │ 录音线程 │  ← 采集音频
    └────┬────┘
         │
    ┌────▼─────────┐
    │  任务队列     │  ← 最多10个任务
    │  [1][2][3]   │
    └────┬─────────┘
         │
    ┌────▼────┐
    │ 转录线程 │  ← 后台处理
    └────┬────┘
         │
    ┌────▼────┐
    │ 输出文字 │
    └─────────┘
```

### 线程安全
- 使用 `queue.Queue` 进行线程间通信（线程安全）
- 使用 `threading.Lock` 保护音频缓冲区
- 使用 `threading.Event` 进行状态同步

### 资源管理
- 转录线程在初始化时启动，cleanup时优雅停止
- 等待队列清空（最多10秒超时）
- 自动清理临时文件和内存

## 📝 日志输出示例

```
2025-10-01 14:30:00 [INFO] 转录工作线程已启动
2025-10-01 14:30:05 [INFO] Transcription worker starting
2025-10-01 14:30:10 [INFO] 录音已提交到转录队列（任务 #1），队列中有 1 个待处理任务
2025-10-01 14:30:11 [INFO] 开始处理转录任务 #1，队列剩余: 0
2025-10-01 14:30:13 [INFO] 转写成功: 你好世界 (推理 2.15s) [已完成 1/1，队列剩余 0]
2025-10-01 14:30:15 [INFO] 录音已提交到转录队列（任务 #2），队列中有 1 个待处理任务
2025-10-01 14:30:15 [INFO] 开始录音（后台还有 1 个转录任务正在处理）
```

## ⚙️ 配置选项

队列大小可以在代码中调整：
```python
# app/transcribe.py, line 69
self._transcription_queue: "queue.Queue[Optional[np.ndarray]]" = queue.Queue(maxsize=10)
```

超时设置：
```python
# 停止转录工作线程时的超时（秒）
self._stop_transcription_worker(timeout=10.0)
```

### 录音大小兜底

- 默认单次录音最大大小为 20MB。达到阈值会自动停止录音并提交转录，日志同时显示字节与 MB。
- 可在配置中调整：

```python
# app/config.py
"audio": {
    ...
    "max_session_bytes": 20 * 1024 * 1024,  # 单次录音大小上限
}
```

### 并发控制与线程安全

#### 防抖机制
- 热键触发添加200ms防抖，避免快速重复按键导致状态混乱
- 实现位置：`main.py` 的 `_toggle()` 函数
- 使用 `time.monotonic()` 确保不受系统时间调整影响

#### 锁粒度优化
- `stop()` 方法采用两阶段设计：
  1. **第一阶段（锁内）**：快速更新共享状态，保存资源引用
  2. **第二阶段（锁外）**：执行耗时操作（I/O、线程join、音频处理）
- 减少锁持有时间，提高并发性能

#### 资源隔离
- `stop()` 在锁内保存当前会话的线程引用
- 锁外操作保存的引用，避免操作到新会话的资源
- 防止"旧stop处理 + 新start启动"的竞态条件

#### 死锁避免
- capture线程调用 `stop(_from_capture_thread=True)` 跳过线程join
- 防止线程等待自己导致的死锁

## 🎉 用户体验提升

- ✅ **无感知延迟**：按F2立即响应，不再卡顿
- ✅ **连续录音**：可以快速连续录制多段语音
- ✅ **后台处理**：转录在后台进行，不影响操作
- ✅ **自动输出**：转录完成后自动输入文字，按顺序输出
- ✅ **状态透明**：日志中显示队列状态，一目了然

## 🔍 故障排查

### 队列满了怎么办？
```
[ERROR] 转录队列已满，无法提交新任务！请等待当前转录完成。
```
**原因**：10个任务都在排队，转录速度跟不上录音速度
**解决**：等待几秒让队列消化，或增大队列大小

### 转录线程卡住？
```
[WARNING] 转录工作线程未能在5秒内结束
```
**原因**：转录任务耗时过长
**解决**：检查FunASR服务是否正常，考虑使用GPU加速

## 📈 性能指标

- **响应延迟**：~50ms（停止录音到返回）
- **队列容量**：10个任务
- **内存占用**：每个任务约2-5MB（取决于录音时长）
- **并发能力**：1个转录 + 1个录音同时进行

---

**版本**：v2.0  
**更新时间**：2025-10-01  
**作者**：AI Assistant




