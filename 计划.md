我先快速查看现有项目里可复用的关键模块实现方式（文本注入、VAD/录音、日志、热键等），以便给出“可复用 vs 需重写”的清单与新项目架构建议。随后我会给出任务分解和实施里程碑。

[3 tools called]

我看完了 `clipboard.js`、`hotkeyManager.js`、`logManager.js` 和现有的 `funasr_server.py` 的要点，可以直接借鉴热键/文本注入/日志与 FunASR 启动策略。下面给你一份精炼的执行规划和“可复用 vs 需重写”清单。

### 项目整体规划（无 GUI，Windows 专注，ASR-only）✅ 已完成 v2.0
- 架构
  - 单进程 Python CLI/常驻进程。
  - 模块：热键管理 → 录音缓冲（会话）→ **异步转写队列** → 文本输出(粘贴/打字) → 日志。
  - **v2.0 新增**：独立转录工作线程，任务队列机制，线程安全保护
- 数据流 (v2.0 优化)
  - F2 切换会话：开始录音清状态；再次 F2 停止采集（立即返回~50ms）
  - 音频提交到异步队列 → 后台转录线程处理 → 按顺序输出文本
  - **关键改进**：停止录音立即返回，用户可马上开始下一次录音，转录在后台进行
  - 支持快速连续录音，最多10个任务排队，按提交顺序依次处理
  - 输出策略：优先"粘贴"，失败降级"逐字符打字"。
- 模型与适配
  - 初期只接 FunASR（ASR+VAD+PUNC 可选），接口抽象为 `IAsrBackend.transcribe(wav_path, opts)->{text,confidence}`。
  - 预留 `whisper/faster-whisper`、纯 ONNX 的适配接口；通过配置选择模型/后端。
- 日志与诊断
  - 路径：`logs/`，文件：`app.log`、`recent.wav`。
  - 记录热键/录音开始结束/整段样本数/转录耗时/输出动作；停止录音后自动保存最近一次会话音频到 `logs/recent.wav`（覆盖）。

### 现有项目“可直接借鉴/迁移”的部分
- 文本注入的降级策略与粘贴优先方案
- FunASR 预初始化与并行加载模型的做法
  - 参考 `funasr_server.py` 中三个模型并行加载、一次常驻、后续复用；在新工程启动时完成加载，减少首段延迟。
- 模型下载/校验理念
  - 直接复用你仓库的 `download_models.py` 作为一键准备脚本（可选），或迁移其“按行 JSON 进度输出”的做法。

### 需要重写/新开发的部分（Python 实现）
- 热键与会话控制（无 Electron）
  - 全局 F2 切换；停止录音后自动保存最近会话到 `logs/recent.wav`（覆盖）。建议 `keyboard` 或 `pywin32`。
- 会话式采集与优雅停止
  - `sounddevice` WASAPI 采集；仅缓冲音频帧。
  - 停止录音后一次性合并缓冲并进行单次转写与输出。
- 文本输出（Windows）
  - 方案A：剪贴板粘贴（首选）；`pywin32`/`ctypes` 模拟 Ctrl+V，恢复原剪贴板内容。
  - 方案B：逐字符 `SendInput`；对中文 IME 可能有副作用，仅作兜底。
- ASR 适配层
  - `FunASRBackend`：`AutoModel(...).generate()`；提供语言、批量秒数、热词参数。
- 诊断与指标
  - 记录“开始→停止→合并→转写→注入”的时间线；打印推理耗时。

### 技术选型（Python）
- 音频：sounddevice 或 soundcard（WASAPI），numpy
- ASR：funasr>=1.2.7，torch/torchaudio，librosa，numpy<2
- 热键/注入：keyboard + pywin32 或 ctypes SendInput，pyperclip 作为剪贴板备选
- 日志：logging（JSON formatter 可选）
- 打包：PyInstaller（单文件可选），或 uv 打包环境

### 配置示例（config.json）
```json
{
  "hotkeys": { "toggle": "f2" },
  "audio": { "sr": 16000, "block_ms": 20, "device": "default" },
  "asr": { "backend": "funasr", "use_punc": true, "language": "auto" },
  "output": { "method": "auto", "dedupe": true },
  "logging": { "dir": "/logs", "level": "info" }
}
```

### 里程碑与验收
- ✅ M1 基础通路（已完成）
  - 录音 → 文件落地 → FunASR 单次转写 → 粘贴/打字输出；F2 开/关，日志落地。
- ✅ M2 单次转写模式（已完成）
  - 会话缓冲与合并、单次转写、输出与日志；停止后自动导出 `logs/recent.wav`；配置化输出策略。
- ✅ M3 稳定性与性能（已完成 v2.0）
  - **异步转录架构**：停止录音立即返回，响应速度提升60倍（3秒→50ms）
  - **任务队列机制**：支持快速连续录音，最多10个任务排队
  - **内存泄漏修复**：音频缓冲区自动清理，GPU显存定期释放
  - **线程安全**：使用锁和队列保护共享资源
  - **优雅清理**：程序退出时等待队列清空（最多10秒超时）
  - 异常处理（无设备、权限）、配置化、日志增强（队列状态、GPU信息）
- 🔜 M4 可扩展后端（规划中）
  - 增加 `WhisperBackend` 或 `ONNXBackend`，接口保持不变；配置切换。

### 你关心的点逐条落地 ✅
- ✅ F2 开始/停止：开始时清状态，停止后立即返回（~50ms），转录在后台异步进行
- ✅ 准确率优先：整段提交，减少切分误差；FunASR标点恢复已集成
- ✅ 用户体验：快速响应，支持快速连续录音，转录按顺序自动输出
- ✅ 内存安全：自动清理缓冲区、GPU显存，无内存泄漏
- ✅ 非 GUI：纯 CLI/后台进程；后续若要 GUI，仅包一层设置面板即可
- 🔜 "像 Ollama 一样可换模型"：通过后端适配器 + 配置选择，先 FunASR，后续加 whisper/onnx 也无需改上层

### v2.0 架构改进详情（2025-10-01）

#### 异步转录架构
```
┌─────────────────┐
│   主线程        │  
│  (UI/热键响应)  │  ← F2按键，立即响应 (~50ms)
└────────┬────────┘
         │
    ┌────▼────┐
    │ 录音线程 │  ← 采集音频，填充缓冲区
    └────┬────┘
         │ stop() 提交任务
    ┌────▼─────────┐
    │  任务队列     │  ← 最多10个任务 (线程安全)
    │  [1][2][3]   │
    └────┬─────────┘
         │
    ┌────▼────┐
    │ 转录线程 │  ← 后台持续处理，按顺序转录
    └────┬────┘
         │
    ┌────▼────┐
    │ 输出文字 │  ← 自动输入到焦点窗口
    └─────────┘
```

#### 核心改进
1. **立即响应**：stop()从阻塞3秒改为立即返回50ms（提升60倍）
2. **并发能力**：支持同时进行：1个录音 + 1个转录
3. **队列缓冲**：最多10个任务排队，防止快速连续操作丢失
4. **内存安全**：
   - 缓冲区线程锁保护
   - 异常情况下也会清理
   - GPU显存每10次转录自动清理
5. **状态透明**：日志显示队列状态、任务进度、完成统计

#### 技术实现
- 使用 `queue.Queue`（线程安全）进行任务传递
- 使用 `threading.Lock` 保护音频缓冲区访问
- 使用 `threading.Event` 进行状态同步
- 转录工作线程在初始化时启动，cleanup时优雅停止
- 程序退出前等待队列清空（最多10秒超时）

#### 性能指标
- 响应延迟：~50ms（停止录音到返回）
- 队列容量：10个任务
- 内存占用：每任务约2-5MB（取决于录音时长）
- 并发能力：1录音 + 1转录同时进行